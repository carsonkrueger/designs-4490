# Thought process

    I designed my symbol table to not include references to avoid any Rc<RefCell> shenanigans. I also find this implementation pretty easy to follow.

    The Symbol table assumes the correct scope id's are generated by the user (me). My symbol table generator visitor will use a scope counter and increment it every time it enters a block. The visitor will use a stack to keep record of its current scope id and parents.

    I might to modify my AST to keep track of which scope it belongs to so that future visitors can easily use the symbol table without having to calculate scope values again. I'm assuming during desugaring I will need to use the symbol table and if the tree has changed then how will I calculate scope values again?

# Symbol Table

    scopes: Vec<Scope>  // Scope index represents their unique id

    fn get(&self, from_scope: usize, id: &str) -> Option<&Symbol>
    fn try_insert(&mut self, from_scope: usize, symbol: Symbol) -> Result<(), ()>

## Scope

    scope: usize                    // Scope id, ex: 2
    parent: Option<usize>           // Parent scope id, ex: Some(1), global = 0
    HashMap<String, Symbol> symbols // String = identifier

    fn get(&self, from_scope: usize, id: &str) -> Option<&Symbol>
    fn try_insert(&mut self, from_scope: usize, symbol: Symbol) -> Result<(), ()>

## Symbol

    identifier: String
    type: ArrType       // Array & Base enum variants. Not in this design.
    scope_id: usize
    is_static: bool
    is_private: bool

I don't need the run time value, but do I need the L value?
When assigning to a symbol x = 0, I'm guessing the actual L value will be determined during desurgaring?

## ScalarType Enum

This enum already exists, along with ArrType which allows arrays, and was used to create my AST. I am adding the Name variant to help create types for this milestone. I chose this path after trying a Symbol Enum (Var, Method, Obj) approach as this has been much easier to deal with. However, using this ScalarType::Name variant means that I don't even need to use the Name::Var variant since everything that is stored in the Var can be stored in just a symbol, so I believe to be a design issue.

    Void,
    Null,
    Char,
    Int,
    Bool,
    Str,
    Unknown
    Identifier(String)
    Name(Name)          // add this variant to simplify type checking
    Unknown             // add this variant to help with errors

## Name Enum

    Obj {
        class_name: String
        scope: usize
        child_scope: usize
        static_obj: bool
    }
    Method {
        scope: usize
        child_scope: usize
        return_type: ArrType
        params: Vec<ArrType>
    }
    Var {
        scope: usize
        type_: ArrType,
    }
